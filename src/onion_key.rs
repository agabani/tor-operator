use std::{collections::BTreeMap, sync::Arc, time::Duration};

use futures::StreamExt;
use k8s_openapi::{
    api::core::v1::Secret,
    apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition,
    apimachinery::pkg::apis::meta::v1::{Condition, Time},
    chrono::Utc,
    ByteString,
};
use kube::{
    core::ObjectMeta,
    runtime::{controller::Action, watcher::Config as WatcherConfig, Controller},
    Client, CustomResource, CustomResourceExt, Resource, ResourceExt,
};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::{
    kubernetes::{
        self, error_policy, Annotations, Api, ConditionsExt, Labels, Object,
        Resource as KubernetesResource, ResourceName, Subset,
    },
    metrics::Metrics,
    tor::{
        self, ExpandedSecretKey, HiddenServicePublicKey, HiddenServiceSecretKey, Hostname,
        PublicKey,
    },
    Result,
};

/*
 * ============================================================================
 * Custom Resource Definition
 * ============================================================================
 */
/// # `OnionKey`
///
/// An `OnionKey` is an abstraction of a Tor Onion Key.
///
/// A Tor Onion Key consists of the following files:
///
/// - `hostname`
/// - `hs_ed25519_public_key`
/// - `hs_ed25519_public_key`
///
/// A user can import their existing Tor Onion Key by creating a secret.
///
/// ```ignore
/// kubectl create secret generic tor-ingress-example \
///   --from-file=hostname=./hostname \
///   --from-file=hs_ed25519_public_key=./hs_ed25519_public_key \
///   --from-file=hs_ed25519_secret_key=./hs_ed25519_secret_key
/// ```
///
/// A user can have the Tor Operator create a new random Tor Onion Key by using the
/// auto generate feature controlled by `.autoGenerate`.
#[allow(clippy::module_name_repetitions)]
#[derive(CustomResource, JsonSchema, Deserialize, Serialize, Debug, Default, Clone, PartialEq)]
#[kube(
    derive = "Default",
    derive = "PartialEq",
    group = "tor.agabani.co.uk",
    kind = "OnionKey",
    namespaced,
    printcolumn = r#"{"name":"Hostname", "type":"string", "description":"The hostname of the OnionKey", "jsonPath":".status.hostname"}"#,
    printcolumn = r#"{"name":"Auto Generated", "type":"boolean", "description":"Auto generated OnionKey", "jsonPath":".status.autoGenerated"}"#,
    printcolumn = r#"{"name":"State", "type":"string", "description":"Human readable description of state", "jsonPath":".status.summary.Ready"}"#,
    printcolumn = r#"{"name":"Age", "type":"date", "jsonPath":".metadata.creationTimestamp"}"#,
    status = "OnionKeyStatus",
    version = "v1"
)]
#[serde(rename_all = "camelCase")]
pub struct OnionKeySpec {
    /// # Auto Generate
    ///
    /// Auto generate a random Onion Key. default: false.
    ///
    /// ## Auto Generate: False
    ///
    /// Tor Operator will use an existing Onion Key from the Secret specified
    /// in `.secret.name`.
    ///
    /// ## Auto Generate: True
    ///
    /// The Tor Operator will generate a random Onion Key and save it in the
    /// secret specified in `.secret.name`.
    ///
    /// If the `OnionKey`'s secret key is missing or malformed, the Tor Operator
    /// will recreate the secret key.
    ///
    /// If the `OnionKey`'s public key is missing, malformed, or does not match
    /// the secret key, the Tor Operator will deterministically recreate the
    /// public key from the secret key.
    ///
    /// If the `OnionKey`'s hostname is missing, malformed, or does not match
    /// the public key, the Tor Operator will deterministically recreate the
    /// hostname from the public key.
    #[serde(default)]
    pub auto_generate: bool,

    /// Secret settings.
    pub secret: OnionKeySpecSecret,
}

#[allow(clippy::module_name_repetitions)]
#[derive(JsonSchema, Deserialize, Serialize, Debug, Default, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct OnionKeySpecSecret {
    /// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: <http://kubernetes.io/docs/user-guide/annotations>
    pub annotations: Option<BTreeMap<String, String>>,

    /// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: <http://kubernetes.io/docs/user-guide/labels>
    pub labels: Option<BTreeMap<String, String>>,

    /// Name of the secret.
    ///
    /// Secret data must have keys `hostname`, `hs_ed25519_public_key` and
    /// `hs_ed25519_secret_key`.
    pub name: String,
}

#[allow(clippy::module_name_repetitions)]
#[derive(JsonSchema, Deserialize, Serialize, Debug, Default, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct OnionKeyStatus {
    /// Auto generated `OnionKey`.
    pub auto_generated: bool,

    /// Represents the latest available observations of a deployment's current state.
    ///
    /// ### Ready
    ///
    /// `SecretNotFound`,
    /// `SecretKeyNotFound`, `SecretKeyMalformed`,
    /// `PublicKeyNotFound`, `PublicKeyMalformed`, `PublicKeyMismatch`,
    /// `HostnameNotFound`, `HostnameMalformed`, `HostnameMismatch`,
    /// `Ready`
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub conditions: Vec<Condition>,

    /// `OnionKey` hostname.
    ///
    /// The hostname is only populated once `state` is ready.
    pub hostname: Option<String>,

    /// Represents the latest available observations of a deployment's current state.
    #[serde(default)]
    pub summary: BTreeMap<String, String>,
}

impl OnionKey {
    #[must_use]
    pub fn auto_generate(&self) -> bool {
        self.spec.auto_generate
    }

    #[must_use]
    pub fn hostname(&self) -> Option<Hostname> {
        self.status
            .as_ref()
            .and_then(|status| status.hostname.as_ref())
            .cloned()
            .map(Hostname::new)
    }

    #[must_use]
    pub fn secret_annotations(&self) -> Option<Annotations> {
        self.spec.secret.annotations.clone().map(Into::into)
    }

    #[must_use]
    pub fn secret_labels(&self) -> Option<Labels> {
        self.spec.secret.labels.clone().map(Into::into)
    }

    #[must_use]
    pub fn secret_name(&self) -> ResourceName {
        ResourceName::from(&self.spec.secret.name)
    }

    #[must_use]
    pub fn status_conditions(&self) -> Option<&Vec<Condition>> {
        self.status.as_ref().map(|f| f.conditions.as_ref())
    }
}

impl KubernetesResource for OnionKey {
    type Spec = OnionKeySpec;

    fn spec(&self) -> &Self::Spec {
        &self.spec
    }
}

impl Object for OnionKey {
    const APP_KUBERNETES_IO_COMPONENT_VALUE: &'static str = "onion-key";

    type Status = OnionKeyStatus;

    fn status(&self) -> &Option<Self::Status> {
        &self.status
    }
}

impl Subset for OnionKeySpec {
    fn is_subset(&self, superset: &Self) -> bool {
        self == superset
    }
}

#[must_use]
pub fn generate_custom_resource_definition() -> CustomResourceDefinition {
    OnionKey::crd()
}

/*
 * ============================================================================
 * Config
 * ============================================================================
 */
pub struct Config {}

/*
 * ============================================================================
 * Controller
 * ============================================================================
 */
pub async fn run_controller(client: Client, config: Config, metrics: Metrics) {
    metrics.kubernetes_api_usage_count::<OnionKey>("watch");
    metrics.kubernetes_api_usage_count::<Secret>("watch");
    Controller::new(
        kube::Api::<OnionKey>::all(client.clone()),
        WatcherConfig::default(),
    )
    .owns(
        kube::Api::<Secret>::all(client.clone()),
        WatcherConfig::default(),
    )
    .shutdown_on_signal()
    .run(
        reconciler,
        error_policy,
        Arc::new(Context {
            client,
            _config: config,
            metrics,
        }),
    )
    .for_each(|_| async {})
    .await;
}

/*
 * ============================================================================
 * Context
 * ============================================================================
 */
struct Context {
    client: Client,
    _config: Config,
    metrics: Metrics,
}

impl kubernetes::Context for Context {
    fn metrics(&self) -> &Metrics {
        &self.metrics
    }
}

/*
 * ============================================================================
 * State
 * ============================================================================
 */
enum State {
    SecretNotFound,
    SecretKeyNotFound,
    SecretKeyMalformed(tor::Error),
    PublicKeyNotFound,
    PublicKeyMalformed(tor::Error),
    PublicKeyMismatch,
    HostnameNotFound,
    HostnameMalformed(tor::Error),
    HostnameMismatch,
    Ready(Hostname),
}

impl From<&State> for Vec<Condition> {
    fn from(value: &State) -> Self {
        vec![Condition {
            last_transition_time: Time(Utc::now()),
            message: match value {
                State::SecretNotFound => "The secret was not found.".into(),
                State::SecretKeyNotFound => "The secret key was not found.".into(),
                State::SecretKeyMalformed(e) => format!("The secret key is malformed: {e}."),
                State::PublicKeyNotFound => "The public key was not found.".into(),
                State::PublicKeyMalformed(e) => format!("The public key is malformed: {e}."),
                State::PublicKeyMismatch => "The public key does not match the secret key.".into(),
                State::HostnameNotFound => "The hostname was not found.".into(),
                State::HostnameMalformed(e) => format!("The hostname is malformed: {e}."),
                State::HostnameMismatch => "The hostname does not much the public key.".into(),
                State::Ready(_) => "The OnionKey is ready.".into(),
            },
            observed_generation: None,
            reason: match value {
                State::SecretNotFound => "SecretNotFound".into(),
                State::SecretKeyNotFound => "SecretKeyNotFound".into(),
                State::SecretKeyMalformed(_) => "SecretKeyMalformed".into(),
                State::PublicKeyNotFound => "PublicKeyNotFound".into(),
                State::PublicKeyMalformed(_) => "PublicKeyMalformed".into(),
                State::PublicKeyMismatch => "PublicKeyMismatch".into(),
                State::HostnameNotFound => "HostnameNotFound".into(),
                State::HostnameMalformed(_) => "HostnameMalformed".into(),
                State::HostnameMismatch => "HostnameMismatch".into(),
                State::Ready(_) => "Ready".into(),
            },
            status: if let State::Ready(_) = value {
                "True".into()
            } else {
                "False".into()
            },
            type_: "Ready".into(),
        }]
    }
}

/*
 * ============================================================================
 * Reconciler
 * ============================================================================
 */
#[tracing::instrument(skip_all)]
async fn reconciler(object: Arc<OnionKey>, ctx: Arc<Context>) -> Result<Action> {
    let _timer = ctx
        .metrics
        .count_and_measure(OnionKey::APP_KUBERNETES_IO_COMPONENT_VALUE);
    tracing::info!("reconciling");

    let namespace = object.try_namespace()?;

    let annotations = Annotations::new();
    let labels = object.try_labels()?;

    // Secret
    let state = reconcile_secret(
        &Api::new(
            kube::Api::namespaced(ctx.client.clone(), &namespace),
            ctx.metrics.clone(),
        ),
        &object,
        &annotations,
        &labels,
    )
    .await?;

    // OnionKey
    reconcile_onion_key(
        &Api::new(
            kube::Api::namespaced(ctx.client.clone(), &namespace),
            ctx.metrics.clone(),
        ),
        &object,
        &state,
    )
    .await?;

    tracing::info!("reconciled");

    match state {
        State::Ready(_) => Ok(Action::requeue(Duration::from_secs(3600))),
        _ => Ok(Action::requeue(Duration::from_secs(5))),
    }
}

async fn reconcile_secret(
    api: &Api<Secret>,
    object: &OnionKey,
    annotations: &Annotations,
    labels: &Labels,
) -> Result<State> {
    let secret = api.get_opt(&object.secret_name()).await?;

    let (state, secret) = generate_secret(object, &secret, annotations, labels);

    if let Some(secret) = secret {
        if let State::Ready(_) = state {
            api.sync(object, [((), secret)].into()).await?;
        }
    }

    Ok(state)
}

async fn reconcile_onion_key(api: &Api<OnionKey>, object: &OnionKey, state: &State) -> Result<()> {
    let conditions = object
        .status_conditions()
        .unwrap_or(&Vec::new())
        .merge_from(&state.into());

    let summary = conditions
        .iter()
        .fold(BTreeMap::new(), |mut summary, condition| {
            summary.insert(condition.type_.clone(), condition.reason.clone());
            summary
        });

    api.update_status(
        object,
        OnionKeyStatus {
            hostname: match &state {
                State::Ready(hostname) => Some(hostname.to_string()),
                _ => None,
            },
            auto_generated: object.auto_generate(),
            conditions,
            summary,
        },
    )
    .await
}

/// only returns a secret if a change needs to be made...
#[allow(clippy::too_many_lines)]
fn generate_secret(
    object: &OnionKey,
    secret: &Option<Secret>,
    annotations: &Annotations,
    labels: &Labels,
) -> (State, Option<Secret>) {
    fn generate(
        object: &OnionKey,
        annotations: &Annotations,
        labels: &Labels,
        public_key: &PublicKey,
        secret_key: &ExpandedSecretKey,
        hostname: &Hostname,
    ) -> Secret {
        Secret {
            metadata: ObjectMeta {
                name: Some(object.secret_name().into()),
                annotations: Some(
                    annotations
                        .clone()
                        .append_reverse(object.secret_annotations())
                        .into(),
                ),
                labels: Some(labels.clone().append_reverse(object.secret_labels()).into()),
                owner_references: Some(vec![object.controller_owner_ref(&()).unwrap()]),
                ..Default::default()
            },
            data: Some(BTreeMap::from([
                ("hostname".into(), ByteString(Vec::<u8>::from(hostname))),
                (
                    "hs_ed25519_public_key".into(),
                    ByteString(Vec::<u8>::from(&HiddenServicePublicKey::from(public_key))),
                ),
                (
                    "hs_ed25519_secret_key".into(),
                    ByteString(Vec::<u8>::from(&HiddenServiceSecretKey::from(secret_key))),
                ),
            ])),
            ..Default::default()
        }
    }

    let auto_generate = object.auto_generate();

    let Some(secret) = secret else {
        if !auto_generate {
            return (State::SecretNotFound, None);
        }

        tracing::info!("generating secret key");
        let secret_key = ExpandedSecretKey::generate();

        tracing::info!("generating public key");
        let public_key = PublicKey::from(&secret_key);

        tracing::info!("generating hostname");
        let hostname = Hostname::from(&public_key);

        let secret = generate(
            object,
            annotations,
            labels,
            &public_key,
            &secret_key,
            &hostname,
        );

        return (State::Ready(hostname), Some(secret));
    };

    let secret_key = secret
        .data
        .as_ref()
        .ok_or(State::SecretKeyNotFound)
        .and_then(|f| {
            f.get("hs_ed25519_secret_key")
                .ok_or(State::SecretKeyNotFound)
        })
        .and_then(|f| HiddenServiceSecretKey::try_from(&f.0).map_err(State::SecretKeyMalformed))
        .and_then(|f| ExpandedSecretKey::try_from(&f).map_err(State::SecretKeyMalformed));

    let secret_key = match secret_key {
        Ok(secret_key) => secret_key,
        Err(validation) => {
            if !auto_generate {
                return (validation, None);
            }

            tracing::info!("generating secret key");
            let secret_key = ExpandedSecretKey::generate();

            tracing::info!("generating public key");
            let public_key = PublicKey::from(&secret_key);

            tracing::info!("generating hostname");
            let hostname = Hostname::from(&public_key);

            let secret = generate(
                object,
                annotations,
                labels,
                &public_key,
                &secret_key,
                &hostname,
            );

            return (State::Ready(hostname), Some(secret));
        }
    };

    let public_key = secret
        .data
        .as_ref()
        .ok_or(State::PublicKeyNotFound)
        .and_then(|f| {
            f.get("hs_ed25519_public_key")
                .ok_or(State::PublicKeyNotFound)
        })
        .and_then(|f| HiddenServicePublicKey::try_from(&f.0).map_err(State::PublicKeyMalformed))
        .and_then(|f| PublicKey::try_from(&f).map_err(State::PublicKeyMalformed))
        .and_then(|f| {
            if f == PublicKey::from(&secret_key) {
                Ok(f)
            } else {
                Err(State::PublicKeyMismatch)
            }
        });

    let public_key = match public_key {
        Ok(public_key) => public_key,
        Err(validation) => {
            if !auto_generate {
                return (validation, None);
            }

            tracing::info!("generating public key");
            let public_key = PublicKey::from(&secret_key);

            tracing::info!("generating hostname");
            let hostname = Hostname::from(&public_key);

            let secret = generate(
                object,
                annotations,
                labels,
                &public_key,
                &secret_key,
                &hostname,
            );

            return (State::Ready(hostname), Some(secret));
        }
    };

    let hostname = secret
        .data
        .as_ref()
        .ok_or(State::HostnameNotFound)
        .and_then(|f| f.get("hostname").ok_or(State::HostnameNotFound))
        .and_then(|f| Hostname::try_from(&f.0).map_err(State::HostnameMalformed))
        .and_then(|f| {
            if f == Hostname::from(&public_key) {
                Ok(f)
            } else {
                Err(State::HostnameMismatch)
            }
        });

    let hostname = match hostname {
        Ok(hostname) => hostname,
        Err(validation) => {
            if !auto_generate {
                return (validation, None);
            }

            tracing::info!("generating hostname");
            let hostname = Hostname::from(&public_key);

            let secret = generate(
                object,
                annotations,
                labels,
                &public_key,
                &secret_key,
                &hostname,
            );

            return (State::Ready(hostname), Some(secret));
        }
    };

    if auto_generate
        && (!annotations.is_subset(object.annotations()) || !labels.is_subset(object.labels()))
    {
        let secret = generate(
            object,
            annotations,
            labels,
            &public_key,
            &secret_key,
            &hostname,
        );

        return (State::Ready(hostname), Some(secret));
    }

    (State::Ready(hostname), None)
}
